<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#@
 output extension=".cs"#><#
// Copyright (c) Microsoft Corporation.  All rights reserved.

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataTools ef = new MetadataTools(this);
MetadataLoader loader = new MetadataLoader(this);
CodeRegion region = new CodeRegion(this);

EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

string inputFile = @"QyfModel.edmx";
EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);
string namespaceName = code.VsNamespaceSuggestion();

EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
if (container == null)
{
    return "// Aucun EntityContainer n'existe dans le modèle, par conséquent, aucun code n'a été généré";
}

WriteHeader(fileManager);
BeginNamespace(namespaceName, code);

#>
<#=Accessibility.ForType(container)#> partial class <#=code.Escape(container)#> : ObjectContext
{
    public const string ConnectionString = "name=<#=container.Name#>";
    public const string ContainerName = "<#=container.Name#>";

    #region Constructors

    public <#=code.Escape(container)#>()
        : base(ConnectionString, ContainerName)
    {
        Initialize();
    }

    public <#=code.Escape(container)#>(string connectionString)
        : base(connectionString, ContainerName)
    {
        Initialize();
    }

    public <#=code.Escape(container)#>(EntityConnection connection)
        : base(connection, ContainerName)
    {
        Initialize();
    }

    private void Initialize()
    {
        // La création de proxys requiert l'utilisation de ProxyDataContractResolver et
        // peut autoriser le chargement différé, qui peut développer le graphique chargé pendant la sérialisation.
        ContextOptions.ProxyCreationEnabled = false;
        ObjectMaterialized += new ObjectMaterializedEventHandler(HandleObjectMaterialized);
    }

    private void HandleObjectMaterialized(object sender, ObjectMaterializedEventArgs e)
    {
        var entity = e.Entity as IObjectWithChangeTracker;
        if (entity != null)
        {
            bool changeTrackingEnabled = entity.ChangeTracker.ChangeTrackingEnabled;
            try
            {
                entity.MarkAsUnchanged();
            }
            finally
            {
                entity.ChangeTracker.ChangeTrackingEnabled = changeTrackingEnabled;
            }
            this.StoreReferenceKeyValues(entity);
        }
    }

    #endregion

<#
        region.Begin("Propriétés ObjectSet", 2);

        foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
        {
#>

    <#=Accessibility.ForReadOnlyProperty(entitySet)#> ObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.Escape(entitySet)#>
    {
        get { return <#=code.FieldName(entitySet) #>  ?? (<#=code.FieldName(entitySet)#> = CreateObjectSet<<#=code.Escape(entitySet.ElementType)#>>("<#=entitySet.Name#>")); }
    }
    private ObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.FieldName(entitySet)#>;
<#
        }

        region.End();

        region.Begin("Importations de fonction");

        foreach (EdmFunction edmFunction in container.FunctionImports)
        {
            var parameters = FunctionImportParameter.Create(edmFunction.Parameters, code, ef);
            string paramList = String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName).ToArray());
            if (edmFunction.ReturnParameter == null)
            {
                continue;
            }
            string returnTypeElement = code.Escape(ef.GetElementType(edmFunction.ReturnParameter.TypeUsage));

#>
    <#=AccessibilityAndVirtual(Accessibility.ForMethod(edmFunction))#> ObjectResult<<#=returnTypeElement#>> <#=code.Escape(edmFunction)#>(<#=paramList#>)
    {
<#
            foreach (var parameter in parameters)
            {
                if (!parameter.NeedsLocalVariable)
                {
                    continue;
                }
#>

        ObjectParameter <#=parameter.LocalVariableName#>;

        if (<#=parameter.IsNullableOfT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null"#>)
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", <#=parameter.FunctionParameterName#>);
        }
        else
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", typeof(<#=parameter.RawClrTypeName#>));
        }
<#
            }
#>
        return base.ExecuteFunction<<#=returnTypeElement#>>("<#=edmFunction.Name#>"<#=code.StringBefore(", ", String.Join(", ", parameters.Select(p => p.ExecuteParameterName).ToArray()))#>);
    }
<#
        }
        region.End();
#>
}
<#
    EndNamespace(namespaceName);

    fileManager.StartNewFile(Path.GetFileNameWithoutExtension(Host.TemplateFile) + ".Extensions.cs");
    BeginNamespace(namespaceName, code);
    WriteApplyChanges(code);
    EndNamespace(namespaceName);

    fileManager.Process();
#>
<#+
private void WriteHeader(EntityFrameworkTemplateFileManager fileManager, params string[] extraUsings)
{
    fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré à partir d'un modèle.
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Common;
using System.Data.EntityClient;
using System.Data.Metadata.Edm;
using System.Data.Objects.DataClasses;
using System.Data.Objects;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
<#=String.Join(String.Empty, extraUsings.Select(u => "using " + u + ";" + Environment.NewLine).ToArray())#>
<#+
    fileManager.EndBlock();
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}

string AccessibilityAndVirtual(string accessibility)
{
    if (accessibility != "private")
    {
        return accessibility + " virtual";
    }

    return accessibility;
}
#>

<#+
void WriteApplyChanges(CodeGenerationTools code)
{
#>
public static class SelfTrackingEntitiesContextExtensions
{
    /// <summary>
    /// ApplyChanges prend les modifications d'un jeu d'entités connectées et les applique à un ObjectContext.
    /// </summary>
    /// <typeparam name="TEntity">Type attendu de l'ObjectSet</typeparam>
    /// <param name="objectSet">L'ObjectSet faisant référence à l'ObjectContext auquel s'appliqueront les modifications.</param>
    /// <param name="entity">Entité servant de point d'entrée du graphique de l'objet contenant les modifications.</param>
    public static void ApplyChanges<TEntity>(this ObjectSet<TEntity> objectSet, TEntity entity) where TEntity : class, IObjectWithChangeTracker
    {
        if (objectSet == null)
        {
            throw new ArgumentNullException("objectSet");
        }

        objectSet.Context.ApplyChanges<TEntity>(objectSet.EntitySet.EntityContainer.Name + "." + objectSet.EntitySet.Name, entity);
    }

    /// <summary>
    /// ApplyChanges prend les modifications d'un jeu d'entités connectées et les applique à un ObjectContext.
    /// </summary>
    /// <typeparam name="TEntity">Type attendu de l'EntitySet</typeparam>
    /// <param name="context">ObjectContext auquel s'appliqueront les modifications.</param>
    /// <param name="entitySetName">Nom EntitySet de l'entité.</param>
    /// <param name="entity">Entité servant de point d'entrée du graphique de l'objet contenant les modifications.</param>
    public static void ApplyChanges<TEntity>(this ObjectContext context, string entitySetName, TEntity entity) where TEntity : IObjectWithChangeTracker
    {
        if (context == null)
        {
            throw new ArgumentNullException("context");
        }

        if (String.IsNullOrEmpty(entitySetName))
        {
            throw new ArgumentException("Le paramètre de chaîne ne peut pas posséder la valeur null ou être vide.", "entitySetName");
        }

        if (entity == null)
        {
            throw new ArgumentNullException("entity");
        }

        bool lazyLoadingSetting = context.ContextOptions.LazyLoadingEnabled;
        try
        {
            context.ContextOptions.LazyLoadingEnabled = false;

            EntityIndex entityIndex = AddHelper.AddAllEntities(context, entitySetName, entity);
            RelationshipSet allRelationships = new RelationshipSet(context, entityIndex.AllEntities);

            #region Handle Initial Entity State

            foreach (IObjectWithChangeTracker changedEntity in entityIndex.AllEntities.Where(x => x.ChangeTracker.State == ObjectState.Deleted))
            {
                HandleDeletedEntity(context, entityIndex, allRelationships, changedEntity);
            }

            foreach (IObjectWithChangeTracker changedEntity in entityIndex.AllEntities.Where(x => x.ChangeTracker.State != ObjectState.Deleted))
            {
                HandleEntity(context, entityIndex, allRelationships, changedEntity);
            }

            #endregion

            #region Loop through each object state entries

            foreach (IObjectWithChangeTracker changedEntity in entityIndex.AllEntities)
            {
                ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(changedEntity);

                EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(changedEntity.GetType());

                foreach (NavigationProperty navProp in entityType.NavigationProperties)
                {
                    RelatedEnd relatedEnd = entry.GetRelatedEnd(navProp.Name);
                    if(!((AssociationType)relatedEnd.RelationshipSet.ElementType).IsForeignKey)
                    {
                        ApplyChangesToIndependentAssociation(context, (IObjectWithChangeTracker)changedEntity, entry, navProp, relatedEnd, allRelationships);
                    }

                }
            }
            #endregion

            // Rétablir l'état approprié de toutes les relations restantes
            foreach (var relationship in allRelationships)
            {
                context.ObjectStateManager.ChangeRelationshipState(
                    relationship.End0,
                    relationship.End1,
                    relationship.AssociationSet.ElementType.FullName,
                    relationship.AssociationEndMembers[1].Name,
                    relationship.State);
            }
        }
        finally
        {
            context.ContextOptions.LazyLoadingEnabled = lazyLoadingSetting;
        }
    }

    private static void ApplyChangesToIndependentAssociation(ObjectContext context, IObjectWithChangeTracker changedEntity, ObjectStateEntry entry, NavigationProperty navProp,
        IRelatedEnd relatedEnd, RelationshipSet allRelationships)
    {
        ObjectChangeTracker changeTracker = changedEntity.ChangeTracker;

        if (changeTracker.State == ObjectState.Added)
        {
            // Les relations doivent demeurer ajoutées, vous devez donc les supprimer de la liste de toutes les relations
            foreach (object relatedEntity in relatedEnd)
            {
                ObjectStateEntry addedRelationshipEntry =
                            context.ObjectStateManager.ChangeRelationshipState(
                                changedEntity,
                                relatedEntity,
                                navProp.Name,
                                EntityState.Added);

                allRelationships.Remove(addedRelationshipEntry);
            }
        }
        else
        {
            if (navProp.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
            {
                //Gérer la suppression vers FixupCollections
                ObjectList collectionPropertyChanges = null;
                if (changeTracker.ObjectsRemovedFromCollectionProperties.TryGetValue(navProp.Name, out collectionPropertyChanges))
                {
                    foreach (var removedEntityFromAssociation in collectionPropertyChanges)
                    {
                        ObjectStateEntry deletedRelationshipEntry =
                            context.ObjectStateManager.ChangeRelationshipState(
                                changedEntity,
                                removedEntityFromAssociation,
                                navProp.Name,
                                EntityState.Deleted);

                        allRelationships.Remove(deletedRelationshipEntry);
                    }
                }

                //Gérer l'ajout à FixupCollection
                if (changeTracker.ObjectsAddedToCollectionProperties.TryGetValue(navProp.Name, out collectionPropertyChanges))
                {
                    foreach (var addedEntityFromAssociation in collectionPropertyChanges)
                    {
                        ObjectStateEntry addedRelationshipEntry =
                            context.ObjectStateManager.ChangeRelationshipState(
                                changedEntity,
                                addedEntityFromAssociation,
                                navProp.Name,
                                EntityState.Added);

                        allRelationships.Remove(addedRelationshipEntry);
                    }
                }
            }
            else
            {

                // Gérer les valeurs de relation d'origine
                object originalReferenceValue;
                if (changeTracker.OriginalValues.TryGetValue(navProp.Name, out originalReferenceValue))
                {
                    if (originalReferenceValue != null)
                    {
                        //Capturer la suppression d'association
                        ObjectStateEntry deletedRelationshipEntry =
                            context.ObjectStateManager.ChangeRelationshipState(
                                entry.Entity,
                                originalReferenceValue,
                                navProp.Name,
                                EntityState.Deleted);

                        allRelationships.Remove(deletedRelationshipEntry);
                    }

                    //Capturer l'ajout d'association
                    object currentReferenceValue = null;
                    foreach (object o in relatedEnd)
                    {
                        currentReferenceValue = o;
                        break;
                    }
                    if (currentReferenceValue != null)
                    {
                        ObjectStateEntry addedRelationshipEntry =
                            context.ObjectStateManager.ChangeRelationshipState(
                                changedEntity,
                                currentReferenceValue,
                                navProp.Name,
                                EntityState.Added);

                        allRelationships.Remove(addedRelationshipEntry);
                    }
                    // si la valeur actuelle de la référence possède la valeur Null, alors l'utilisateur doit définir la référence d'entité avec la valeur Null
                    // qui est déjà gérée par la suppression de la relation
                }
            }
        }
    }

    // Extrait les informations clés sur la relation à partir des enregistrements ExtendedProperties et OriginalValues de chaque ObjectChangeTracker
    // Cela s'effectue via :
    //  1. La création de toute relation existante spécifiée dans ExtendedProperties
    //  2. Déterminer l'existence d'une relation précédente, et dans ce cas, créer une relation supprimée entre l'entité et l'entité ou valeur de clé précédente
    private static void HandleRelationshipKeys(ObjectContext context, EntityIndex entityIndex, RelationshipSet allRelationships, IObjectWithChangeTracker entity)
    {
        ObjectChangeTracker changeTracker = entity.ChangeTracker;
        if (changeTracker.State == ObjectState.Unchanged ||
            changeTracker.State == ObjectState.Modified ||
            changeTracker.State == ObjectState.Deleted)
        {
            ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(entity);
            EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType());
            RelationshipManager relationshipManager = context.ObjectStateManager.GetRelationshipManager(entity);

            foreach (var entityReference in EnumerateSaveReferences(relationshipManager))
            {
                AssociationSet associationSet = ((AssociationSet)entityReference.RelationshipSet);
                AssociationEndMember fromEnd = associationSet.AssociationSetEnds[entityReference.SourceRoleName].CorrespondingAssociationEndMember;
                AssociationEndMember toEnd = associationSet.AssociationSetEnds[entityReference.TargetRoleName].CorrespondingAssociationEndMember;

                // Rechercher une NavigationProperty pour ce candidat
                NavigationProperty navigationProperty = entityType.NavigationProperties.
                                           SingleOrDefault(x => x.RelationshipType == associationSet.ElementType &&
                                                           x.FromEndMember == fromEnd &&
                                                           x.ToEndMember == toEnd);

                // Gérer les clés de relation dans l'un de ces cas uniquement
                // 1. Il n'existe aucune propriété de navigation
                // 2. La propriété de navigation possède une valeur de référence actuelle null et il n'existe aucun ajout ni suppression
                // 3. La propriété de navigation possède une valeur de référence actuelle, mais il n'existe pas de suppression

                EntityKey currentKey = GetSavedReferenceKey(entityIndex, entityReference, entity, navigationProperty, changeTracker.ExtendedProperties);

                // Obtenir n'importe quelle valeur d'origine à partir des informations de suivi des modifications
                object originalValue = null;
                EntityKey originalKey = null;
                bool hasOriginalValue = false;
                if (changeTracker.OriginalValues != null)
                {
                    // Tenter d'obtenir la valeur originale d'abord à partir de NavigationProperty
                    if (navigationProperty != null)
                    {
                        hasOriginalValue = changeTracker.OriginalValues.TryGetValue(navigationProperty.Name, out originalValue);
                    }
                    // Tenter d'obtenir la valeur originale à partir de la clé de référence en second
                    if (!hasOriginalValue || originalValue == null)
                    {
                        originalKey = GetSavedReferenceKey(entityIndex, entityReference, entity, navigationProperty, changeTracker.OriginalValues);
                    }
                }

                // Créer la relation actuelle
                if (currentKey != null)
                {
                    // Si la clé concerne une entité supprimée, redonner la valeur originale à cette clé et corriger les valeurs de clé des entités
                    // Sinon, établir une nouvelle relation
                    ObjectStateEntry currentEntry;
                    if (context.ObjectStateManager.TryGetObjectStateEntry(currentKey, out currentEntry) &&
                       currentEntry.Entity != null &&
                       currentEntry.State == EntityState.Deleted)
                    {
                        entityReference.EntityKey = null;
                        MoveSavedReferenceKey(entityReference, entity, navigationProperty, changeTracker.ExtendedProperties, changeTracker.OriginalValues);
                        originalKey = currentKey;
                    }
                    else
                    {
                        CreateRelationship(context, entityReference, entry.EntityKey, currentKey, originalKey == null ? EntityState.Unchanged : EntityState.Added);
                    }
                }
                else
                {
                    // Rechercher la clé actuelle
                    // Impossible d'obtenir directement l'EntityKey, car la valeur est null lorsqu'elle pointe vers une entité Added
                    currentKey = entityReference.GetCurrentEntityKey(context);
                }

                // Créer la relation d'origine
                if (originalKey != null)
                {
                    // Si la clé concerne une entité supprimée, pensez à créer une relation supprimée,
                    // sinon, utiliser entityReference pour mettre en place la relation supprimée
                    ObjectStateEntry originalEntry = null;
                    ObjectStateEntry deletedRelationshipEntry = null;
                    if (context.ObjectStateManager.TryGetObjectStateEntry(originalKey, out originalEntry) &&
                       originalEntry.Entity != null &&
                       originalEntry.State == EntityState.Deleted)
                    {
                        allRelationships.Add(entityReference, entry.Entity, originalEntry.Entity, EntityState.Deleted);
                    }
                    else
                    {
                        // Pour créer une relation supprimée avec une clé, détacher d'abord la relation existante entre l'entrée et la clé actuelle (currentKey)
                        EntityState currentRelationshipState = DetachRelationship(context, entityReference, entry, currentKey);

                        // Dans le cas d'une relation 1 à 0..1, détacher la relation entre currentKey et sa cible (targetKey)
                        EntityState targetRelationshipState = EntityState.Detached;
                        EntityReference targetReference = null;
                        EntityKey targetKey = null;
                        if (originalEntry != null &&
                            originalEntry.Entity != null &&
                            originalEntry.RelationshipManager != null &&
                            associationSet.AssociationSetEnds[fromEnd.Name].CorrespondingAssociationEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
                        {
                            targetReference = originalEntry.RelationshipManager.GetRelatedEnd(entityReference.RelationshipName, entityReference.SourceRoleName) as EntityReference;
                            targetKey = targetReference.GetCurrentEntityKey(context);
                            if (targetKey != null)
                            {
                                targetRelationshipState = DetachRelationship(context, targetReference, originalEntry, targetKey);
                            }
                        }


                        // Créer la relation supprimée entre l'entrée et la clé d'origine (originalKey)
                        deletedRelationshipEntry = CreateRelationship(context, entityReference, entry.EntityKey, originalKey, EntityState.Deleted);

                        // ///Rétablir la relation précédente entre l'entrée et la clé actuelle (currentKey)
                        CreateRelationship(context, entityReference, entry.EntityKey, currentKey, currentRelationshipState);

                        // ///Rétablir la relation précédente entre l'entrée d'origine (originalEntry) et sa cible (targetKey)
                        if (targetKey != null)
                        {
                            CreateRelationship(context, targetReference, originalEntry.EntityKey, targetKey, targetRelationshipState);
                        }
                    }
                    if (deletedRelationshipEntry != null)
                    {
                        // Retirer la relation supprimée parmi celles devant être traitées ultérieurement dans ApplyChanges
                        allRelationships.Remove(deletedRelationshipEntry);
                    }
                }
                else if (currentKey == null && originalValue != null && entityReference.IsDependentEndOfReferentialConstraint())
                {
                    // cette relation du graphique ne sera pas reliée, car il n'existe pas de valeur actuelle, mais une valeur originale,
                    // le code de traitement des relations voudra donc supprimer une relation.
                    // nous pouvons ajouter celle-ci, afin qu'elle ait une relation à modifier en supprimée.
                    context.ObjectStateManager.ChangeRelationshipState(
                                                        entry.Entity,
                                                        originalValue,
                                                        entityReference.RelationshipName,
                                                        entityReference.TargetRoleName,
                                                        EntityState.Added);
                }
            }
        }
    }

    private static ObjectStateEntry CreateRelationship(ObjectContext context, EntityReference entityReference, EntityKey fromKey, EntityKey toKey, EntityState state)
    {
        if (state != EntityState.Detached)
        {
            AssociationSet associationSet = ((AssociationSet)entityReference.RelationshipSet);
            AssociationEndMember fromEnd = associationSet.AssociationSetEnds[entityReference.SourceRoleName].CorrespondingAssociationEndMember;
            AssociationEndMember toEnd = associationSet.AssociationSetEnds[entityReference.TargetRoleName].CorrespondingAssociationEndMember;

            // définir la relation selon la relation originale dans l'état non modifié
            Debug.Assert(toKey != null, "pourquoi/comment devrions-nous effectuer une suppression avec une originalKey Null ?");

            if (toKey.IsTemporary)
            {
                // Effacer toute relation existante
                entityReference.EntityKey = null;

                // Si l'entité cible est Added, utilisez Add sur RelatedEnd
                ObjectStateEntry targetEntry;
                context.ObjectStateManager.TryGetObjectStateEntry(toKey, out targetEntry);
                Debug.Assert(targetEntry != null, "L'entrée d'état aurait dû être trouvée");
                ((IRelatedEnd)entityReference).Add(targetEntry.Entity);
            }
            else
            {
                entityReference.EntityKey = toKey;
            }

            ObjectStateEntry relationshipEntry;
            bool found = context.TryGetObjectStateEntry(fromKey, toKey, associationSet, fromEnd, toEnd, out relationshipEntry);
            Debug.Assert(found, "Relation créée introuvable.");

            switch (state)
            {
                case EntityState.Added:
                    break;
                case EntityState.Unchanged:
                    relationshipEntry.AcceptChanges();
                    break;
                case EntityState.Deleted:
                    relationshipEntry.AcceptChanges();
                    entityReference.EntityKey = null;
                    break;
            }
            return relationshipEntry;
        }
        return null;
    }

    private static EntityState DetachRelationship(ObjectContext context, EntityReference entityReference, ObjectStateEntry fromEntry, EntityKey toKey)
    {
        EntityState currentRelationshipState = EntityState.Detached;

        if (toKey != null)
        {
            AssociationSet associationSet = ((AssociationSet)entityReference.RelationshipSet);
            AssociationEndMember fromEnd = associationSet.AssociationSetEnds[entityReference.SourceRoleName].CorrespondingAssociationEndMember;
            AssociationEndMember toEnd = associationSet.AssociationSetEnds[entityReference.TargetRoleName].CorrespondingAssociationEndMember;

            ObjectStateEntry currentRelationshipEntry = null;

            if (context.TryGetObjectStateEntry(fromEntry.EntityKey, toKey, associationSet, fromEnd, toEnd, out currentRelationshipEntry))
            {
                currentRelationshipState = currentRelationshipEntry.State;

                entityReference.EntityKey = null;
                if (currentRelationshipEntry.State == EntityState.Deleted)
                {
                    currentRelationshipEntry.AcceptChanges();
                }
                Debug.Assert(currentRelationshipEntry.State == EntityState.Detached, "la relation n'a pas été détachée");
            }
        }
        return currentRelationshipState;
    }

    private static string CreateReferenceKeyLookup(string keyMemberName, EntityReference reference, NavigationProperty navigationProperty)
    {
        // utilisez la propriété de navigation pouvant être la plus utilisée pour qualifier le membre
        // si disponible
        if (navigationProperty != null)
        {
            return String.Format(CultureInfo.InvariantCulture, "{0}.{1}", navigationProperty.Name, keyMemberName);
        }
        else
        {
            return String.Format(CultureInfo.InvariantCulture, "Navigate({0}.{1}).{2}", reference.RelationshipSet.ElementType.FullName, reference.TargetRoleName, keyMemberName);
        }
    }

    // récupère la clé correspondant à l'EntityReference passé
    // ces clés peuvent être définies pendant l'événement ObjectMaterialized ou via une correction de relation
    private static EntityKey GetSavedReferenceKey(EntityIndex entityIndex, EntityReference reference, object entity, NavigationProperty navigationProperty, IDictionary<string, object> values)
    {
        Debug.Assert(navigationProperty == null || reference.RelationshipSet.ElementType == navigationProperty.RelationshipType, "la référence et la propriété de navigation doivent correspondre");

        EntitySet entitySet = ((AssociationSet)reference.RelationshipSet).AssociationSetEnds[reference.TargetRoleName].EntitySet;

        List<EntityKeyMember> foundKeyMembers = new List<EntityKeyMember>(1);
        bool foundNone = true;
        bool missingSome = false;
        foreach (var keyMember in entitySet.ElementType.KeyMembers)
        {
            string lookupKey = CreateReferenceKeyLookup(keyMember.Name, reference, navigationProperty);
            object value;
            if (values.TryGetValue(lookupKey, out value))
            {
                foundKeyMembers.Add(new EntityKeyMember(keyMember.Name, value));
                foundNone = false;
            }
            else
            {
                missingSome = true;
            }
        }

        if (foundNone)
        {
            // nous n'avons pas trouvé de clé
            return null;
        }
        else if (missingSome)
        {
            throw new InvalidOperationException(
                String.Format(
                    CultureInfo.CurrentCulture,
                    "Les collections OriginalValues ou ExtendedProperties sur le type '{0}' contenaient uniquement une clé partielle pour satisfaire la relation '{1}' qui cible le rôle '{2}'",
                    entity.GetType().FullName,
                    reference.RelationshipName,
                    reference.TargetRoleName));
        }

        EntityKey key = entityIndex.ConvertEntityKey(new EntityKey(reference.GetEntitySetName(), foundKeyMembers));
        return key;
    }

    // Déplace la clé correspondant à l'EntityReference transmise entre une collection source et une collection cible
    private static void MoveSavedReferenceKey(EntityReference reference, object entity, NavigationProperty navigationProperty, IDictionary<string, object> sourceValues, IDictionary<string, object> targetValues)
    {
        Debug.Assert(navigationProperty == null || reference.RelationshipSet.ElementType == navigationProperty.RelationshipType, " la référence et la propriété de navigation doivent correspondre");

        EntitySet entitySet = ((AssociationSet)reference.RelationshipSet).AssociationSetEnds[reference.TargetRoleName].EntitySet;

        bool missingSome = false;
        foreach (var keyMember in entitySet.ElementType.KeyMembers)
        {
            string lookupKey = CreateReferenceKeyLookup(keyMember.Name, reference, navigationProperty);
            object value;
            if (sourceValues.TryGetValue(lookupKey, out value))
            {
                if (targetValues.ContainsKey(lookupKey))
                {
                    targetValues[lookupKey] = value;
                }
                else
                {
                    targetValues.Add(lookupKey, value);
                }
                sourceValues.Remove(lookupKey);
            }
            else
            {
                missingSome = true;
            }
        }

        if (missingSome)
        {
            throw new InvalidOperationException(
                String.Format(
                    CultureInfo.CurrentCulture,
                    " Les collections OriginalValues ou ExtendedProperties sur le type '{0}' contenaient uniquement une clé partielle pour satisfaire la relation '{1}' qui cible le rôle '{2}'",
                    entity.GetType().FullName,
                    reference.RelationshipName,
                    reference.TargetRoleName));
        }
    }

    private static IEnumerable<EntityReference> EnumerateSaveReferences(RelationshipManager manager)
    {
        return manager.GetAllRelatedEnds().OfType<EntityReference>()
                .Where(er => er.RelationshipSet.ElementType.RelationshipEndMembers[er.SourceRoleName].RelationshipMultiplicity != RelationshipMultiplicity.One &&
                    !((AssociationSet)er.RelationshipSet).ElementType.IsForeignKey);
    }

    internal static void StoreReferenceKeyValues(this ObjectContext context, IObjectWithChangeTracker entity)
    {
        if(entity == null)
        {
            throw new ArgumentNullException("entity");
        }

        ObjectStateEntry entry;
        if (!context.ObjectStateManager.TryGetObjectStateEntry(entity, out entry))
        {
            // doit être une requête sans suivi, les informations de clé de référence ne seront pas disponibles
            return;
        }

        var relationshipManager = entry.RelationshipManager;
        EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType());
        foreach (EntityReference entityReference in EnumerateSaveReferences(relationshipManager))
        {
            NavigationProperty navigationProperty = entityType.NavigationProperties.FirstOrDefault(n => n.RelationshipType == entityReference.RelationshipSet.ElementType &&
                    n.FromEndMember.Name == entityReference.SourceRoleName &&
                    n.ToEndMember.Name == entityReference.TargetRoleName);

            object value = entityReference.GetValue();
            if ((navigationProperty == null || value == null) && entityReference.EntityKey != null)
            {
                foreach (var item in entityReference.EntityKey.EntityKeyValues)
                {
                    string key = CreateReferenceKeyLookup(item.Key, entityReference, navigationProperty);
                    entity.ChangeTracker.ExtendedProperties.Add(key, item.Value);
                }
            }
        }
    }

    private static void HandleEntity(ObjectContext context, EntityIndex entityIndex, RelationshipSet allRelationships, IObjectWithChangeTracker entity)
    {
        ChangeEntityStateBasedOnObjectState(context, entity);
        HandleRelationshipKeys(context, entityIndex, allRelationships, entity);
        UpdateOriginalValues(context, entity);
    }

    private static void HandleDeletedEntity(ObjectContext context, EntityIndex entityIndex, RelationshipSet allRelationships, IObjectWithChangeTracker entity)
    {
        HandleRelationshipKeys(context, entityIndex, allRelationships, entity);
        ChangeEntityStateBasedOnObjectState(context, entity);
        UpdateOriginalValues(context, entity);
    }

    private static void UpdateOriginalValues(ObjectContext context, IObjectWithChangeTracker entity)
    {
        if (entity.ChangeTracker.State == ObjectState.Unchanged ||
            entity.ChangeTracker.State == ObjectState.Added ||
            entity.ChangeTracker.OriginalValues == null)
        {
            // rien à faire
            return;
        }

        // nous devons/voulons traiter les propriétés scalaires et complexes

        ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(entity);
        OriginalValueRecord originalValueRecord = entry.GetUpdatableOriginalValues();
        EntityType entityType = context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType());

        // parcourez chaque propriété et déterminez si nous disposons d'une valeur originale pour elle
        // la définir dans ce cas. Parcourir les propriétés ComplexType pour définir des valeurs d'origine
        // pour chacune d'entre elles également
        //
        // il est prévu que les valeurs d'origine soient partiellement allouées, car nous tentons
        // de capturer uniquement les originales pour celles que nous devons avoir (concurrence, sproc, condition, plus ?)
        foreach(EdmProperty property in entityType.Properties)
        {
            object value;
            if(property.TypeUsage.EdmType is PrimitiveType && entity.ChangeTracker.OriginalValues.TryGetValue(property.Name, out value))
            {
                originalValueRecord.SetValue(property, value);
            }
            else if(property.TypeUsage.EdmType is ComplexType)
            {
                OriginalValueRecord complexOriginalValues = originalValueRecord.GetOriginalValueRecord(property.Name);
                UpdateOriginalValues((ComplexType)property.TypeUsage.EdmType, entity.GetType().FullName, property.Name, entity.ChangeTracker.OriginalValues, complexOriginalValues);
            }
        }
    }

    private static void UpdateOriginalValues(ComplexType complexType, string entityTypeName, string propertyPathToType, IDictionary<string, object> originalValueSource, OriginalValueRecord complexOriginalValueRecord)
    {
        // Notez que complexOriginalValueRecord peut posséder la valeur Null
        // un complexOriginalValueRecord avec une valeur Null se produit uniquement si une référence Null est attribuée
        // à une propriété ComplexType, puis donnée à ApplyChanges.
        //
        // parcourez chaque propriété et déterminez si nous disposons d'une valeur originale pour elle
        // la définir dans ce cas. Parcourir les propriétés ComplexType pour définir des valeurs d'origine
        // pour chacune d'entre elles également
        foreach (EdmProperty property in complexType.Properties)
        {
            object value;
            string propertyPath = String.Format(CultureInfo.InvariantCulture, "{0}.{1}", propertyPathToType, property.Name);
            if (property.TypeUsage.EdmType is PrimitiveType && originalValueSource.TryGetValue(propertyPath, out value))
            {
                if (complexOriginalValueRecord != null)
                {
                    complexOriginalValueRecord.SetValue(property, value);
                }
                else if (value != null)
                {
                    Debug.Assert(complexOriginalValueRecord == null, "nous levons uniquement lorsque la valeur n'est pas Null et que l'enregistrement possède la valeur Null");
                    throw new InvalidOperationException(
                        String.Format(
                        CultureInfo.CurrentCulture,
                        "Impossible de définir la valeur originale sur l'objet stocké dans la propriété '{0}' sur le type '{1}', car la propriété a la valeur Null.",
                        propertyPathToType,
                        entityTypeName));
                }
            }
            else if (property.TypeUsage.EdmType is ComplexType)
            {
                OriginalValueRecord nestedOriginalValueRecord = null;
                if (complexOriginalValueRecord != null)
                {
                    nestedOriginalValueRecord = complexOriginalValueRecord.GetOriginalValueRecord(property.Name);
                }
                // récursif jusqu'à la chaîne de types complexes...
                UpdateOriginalValues((ComplexType)property.TypeUsage.EdmType, entityTypeName, propertyPath, originalValueSource, nestedOriginalValueRecord);
            }
        }
    }

    private static OriginalValueRecord GetOriginalValueRecord(this OriginalValueRecord record, string name)
    {
        int ordinal = record.GetOrdinal(name);
        if (!record.IsDBNull(ordinal))
        {
            return record.GetDataRecord(ordinal) as OriginalValueRecord;
        }
        else
        {
            return null;
        }
    }

    private static void SetValue(this OriginalValueRecord record, EdmProperty edmProperty, object value)
    {
        if (value == null)
        {
            Type entityClrType = ((PrimitiveType)edmProperty.TypeUsage.EdmType).ClrEquivalentType;
            if (entityClrType.IsValueType &&
                !(entityClrType.IsGenericType && typeof(Nullable<>) == entityClrType.GetGenericTypeDefinition()))
            {
                // Omettez la définition des valeurs d'origine Null selon des types CLR non nullables, car ObjectStateEntry ne l'autorisera pas
                return;
            }
        }

        int ordinal = record.GetOrdinal(edmProperty.Name);
        record.SetValue(ordinal, value);
    }


    private static void ChangeEntityStateBasedOnObjectState(ObjectContext context, IObjectWithChangeTracker entity)
    {
        switch (entity.ChangeTracker.State)
        {
            case (ObjectState.Added):
                // Pas d'opération : l'entrée d'état est déjà marquée comme ajoutée
                Debug.Assert(context.ObjectStateManager.GetObjectStateEntry(entity).State == EntityState.Added, "L'état aurait dû être Ajouté");
                break;
            case (ObjectState.Unchanged):
                context.ObjectStateManager.ChangeObjectState(entity, EntityState.Unchanged);
                break;
            case (ObjectState.Modified):
                context.ObjectStateManager.ChangeObjectState(entity, EntityState.Modified);
                break;
            case (ObjectState.Deleted):
                context.ObjectStateManager.ChangeObjectState(entity, EntityState.Deleted);
                break;

        }
    }

    private static EntityType GetCSpaceEntityType(this MetadataWorkspace workspace, Type type)
    {
        EntityType ospaceEntityType = null;
        StructuralType cspaceEntityType = null;
        EntityType entityType = null;
        if (workspace.TryGetItem<EntityType>(
            type.FullName,
            DataSpace.OSpace,
            out ospaceEntityType))
        {
            if (workspace.TryGetEdmSpaceType(
                ospaceEntityType,
                out cspaceEntityType))
            {
                entityType = cspaceEntityType as EntityType;
            }
        }
        if(entityType == null)
        {
            throw new ArgumentException(String.Format(CultureInfo.CurrentCulture, "Impossible de trouver un type CSpace pour le type {0}", type.FullName));
        }
        return entityType;
    }

    private static object GetValue(this System.Data.Objects.DataClasses.EntityReference entityReference)
    {
        foreach (object value in entityReference)
        {
            return value;
        }
        return null;
    }

    private static EntityKey GetCurrentEntityKey(this System.Data.Objects.DataClasses.EntityReference entityReference, ObjectContext context)
    {
        EntityKey currentKey = null;
        object currentValue = entityReference.GetValue();
        if (currentValue != null)
        {
            ObjectStateEntry relatedEntry = context.ObjectStateManager.GetObjectStateEntry(currentValue);
            currentKey = relatedEntry.EntityKey;
        }
        else
        {
            currentKey = entityReference.EntityKey;
        }
        return currentKey;
    }

    private static RelatedEnd GetRelatedEnd(this ObjectStateEntry entry, string navigationPropertyIdentity)
    {
        NavigationProperty navigationProperty =
                        GetNavigationProperty(entry.ObjectStateManager.MetadataWorkspace.GetCSpaceEntityType(entry.Entity.GetType()), navigationPropertyIdentity);
        return entry.RelationshipManager.GetRelatedEnd(
            navigationProperty.RelationshipType.FullName, navigationProperty.ToEndMember.Name) as RelatedEnd;
    }

    private static NavigationProperty GetNavigationProperty(this EntityType entityType, string navigationPropertyIdentity)
    {
        NavigationProperty navigationProperty;
        if (!entityType.NavigationProperties.TryGetValue(navigationPropertyIdentity, false, out navigationProperty))
        {
            throw new InvalidOperationException(
                String.Format(
                    CultureInfo.CurrentCulture,
                    "Propriété de navigation '{0}' introuvable dans EntityType '{1}'.",
                    navigationPropertyIdentity,
                    entityType.FullName));
        }
        return navigationProperty;
    }

    private static string GetEntitySetName(this RelatedEnd relatedEnd)
    {
        EntitySet entitySet = ((AssociationSet)relatedEnd.RelationshipSet).AssociationSetEnds[relatedEnd.TargetRoleName].EntitySet;
        return entitySet.EntityContainer.Name + "." + entitySet.Name;
    }

    private static bool IsDependentEndOfReferentialConstraint(this RelatedEnd relatedEnd)
    {
        if (null != relatedEnd.RelationshipSet)
        {
            // REMARQUE Une collection de contraintes référentielles contient généralement 0 ou 1 élément,
            // les performances ne devraient pas constituer un problème dans ce cas
            foreach (ReferentialConstraint constraint in ((AssociationType)relatedEnd.RelationshipSet.ElementType).ReferentialConstraints)
            {
                if (constraint.ToRole.Name == relatedEnd.SourceRoleName)
                {
                    // Exemple :
                    //    Client<C_ID> --- Order<O_ID, Client_ID>
                    //    Contrainte RI : Principale/Depuis <Client.C_ID>,  Dépendante/Vers <Order.Client_ID>
                    // Lorsqu'un RelatedEnd actuel est CollectionOrReference dans les relations d'Order,
                    // constraint.ToRole == this._fromEndProperty == Order
                    return true;
                }
            }
        }
        return false;
    }

    private static bool TryGetObjectStateEntry(this ObjectContext context, EntityKey from, EntityKey to, AssociationSet associationSet, AssociationEndMember fromEnd, AssociationEndMember toEnd, out ObjectStateEntry entry)
    {
        entry = null;
        foreach (var relationshipEntry in (from e in context.ObjectStateManager.GetObjectStateEntries(EntityState.Added | EntityState.Unchanged)
                                           where e.IsRelationship && e.EntitySet == associationSet
                                           select e))
        {
            CurrentValueRecord currentValues = relationshipEntry.CurrentValues;
            int fromOrdinal = currentValues.GetOrdinal(fromEnd.Name);
            int toOrdinal = currentValues.GetOrdinal(toEnd.Name);
            if (((EntityKey)currentValues.GetValue(fromOrdinal)) == from &&
                ((EntityKey)currentValues.GetValue(toOrdinal)) == to)
            {
                entry = relationshipEntry;
                return true;
            }
        }
        return false;
    }

    private sealed class AddHelper
    {
        private readonly ObjectContext _context;
        private readonly EntityIndex _entityIndex;

        // Utilisées pendant le processus d'ajout
        private readonly Queue<Tuple<string, IObjectWithChangeTracker>> _entitiesToAdd;
        private readonly Queue<Tuple<ObjectStateEntry, string, IEnumerable<object>>> _entitiesDuringAdd;

        public static EntityIndex AddAllEntities(ObjectContext context, string entitySetName, IObjectWithChangeTracker entity)
        {
            AddHelper addHelper = new AddHelper(context);

            try
            {
                // Inclure l'élément racine pour démarrer l'Apply
                addHelper.QueueAdd(entitySetName, entity);

                // Ajouter tout
                while (addHelper.HasMore)
                {
                    Tuple<string, IObjectWithChangeTracker> entityInSet = addHelper.NextAdd();
                    // Ajouter l'objet uniquement s'il n'est pas déjà dans le contexte
                    ObjectStateEntry entry = null;
                    if (!context.ObjectStateManager.TryGetObjectStateEntry(entityInSet.Item2, out entry))
                    {
                        context.AddObject(entityInSet.Item1, entityInSet.Item2);
                    }
                }
            }
            finally
            {
                addHelper.Detach();
            }
            return addHelper.EntityIndex;
        }

        private AddHelper(ObjectContext context)
        {
            _context = context;
            _context.ObjectStateManager.ObjectStateManagerChanged += this.HandleStateManagerChange;

            _entityIndex = new EntityIndex(context);
            _entitiesToAdd = new Queue<Tuple<string, IObjectWithChangeTracker>>();
            _entitiesDuringAdd = new Queue<Tuple<ObjectStateEntry, string, IEnumerable<object>>>();
        }

        private void Detach()
        {
            _context.ObjectStateManager.ObjectStateManagerChanged -= this.HandleStateManagerChange;
        }

        private void HandleStateManagerChange(object sender, CollectionChangeEventArgs args)
        {
            if (args.Action == CollectionChangeAction.Add)
            {
                IObjectWithChangeTracker entity = args.Element as IObjectWithChangeTracker;
                ObjectStateEntry entry = _context.ObjectStateManager.GetObjectStateEntry(entity);
                ObjectChangeTracker changeTracker = entity.ChangeTracker;

                changeTracker.ChangeTrackingEnabled = false;
                _entityIndex.Add(entry, changeTracker);

                // Mettre en file d'attente les valeurs de référence supprimées
                var navPropNames = _context.MetadataWorkspace.GetCSpaceEntityType(entity.GetType()).NavigationProperties.Select(n => n.Name);
                var entityRefOriginalValues = changeTracker.OriginalValues.Where(kvp => navPropNames.Contains(kvp.Key));
                foreach (KeyValuePair<string, object> originalValueWithName in entityRefOriginalValues)
                {
                    if (originalValueWithName.Value != null)
                    {
                        _entitiesDuringAdd.Enqueue(new Tuple<ObjectStateEntry, string, IEnumerable<object>>(
                            entry,
                            originalValueWithName.Key,
                            new object[] { originalValueWithName.Value }));
                    }
                }

                // Mettre en file d'attente les valeurs de collection supprimées
                foreach (KeyValuePair<string, ObjectList> collectionPropertyChangesWithName in changeTracker.ObjectsRemovedFromCollectionProperties)
                {
                    _entitiesDuringAdd.Enqueue(new Tuple<ObjectStateEntry, string, IEnumerable<object>>(
                        entry,
                        collectionPropertyChangesWithName.Key,
                        collectionPropertyChangesWithName.Value));
                }
            }
        }

        private EntityIndex EntityIndex
        {
            get { return _entityIndex; }
        }

        private bool HasMore
        {
            get { ProcessNewAdds(); return _entitiesToAdd.Count > 0; }
        }

        private void QueueAdd(string entitySetName, IObjectWithChangeTracker entity)
        {
            if (!_entityIndex.Contains(entity))
            {
                // Mettre l'entité en file d'attente, afin que nous puissions ajouter les éléments 'collection supprimée'
                _entitiesToAdd.Enqueue(new Tuple<string, IObjectWithChangeTracker>(entitySetName, entity));
            }
        }

        private Tuple<string, IObjectWithChangeTracker> NextAdd()
        {
            ProcessNewAdds();
            return _entitiesToAdd.Dequeue();
        }

        private void ProcessNewAdds()
        {
            while (_entitiesDuringAdd.Count > 0)
            {
                Tuple<ObjectStateEntry, string, IEnumerable<object>> relatedEntities = _entitiesDuringAdd.Dequeue();
                RelatedEnd relatedEnd = relatedEntities.Item1.GetRelatedEnd(relatedEntities.Item2);
                string entitySetName = relatedEnd.GetEntitySetName();

                foreach (var targetEntity in relatedEntities.Item3)
                {
                    QueueAdd(entitySetName, targetEntity as IObjectWithChangeTracker);
                }
            }
        }
    }

    private sealed class EntityIndex
    {
        private readonly ObjectContext _context;

        // Ensemble de toutes les entités
        private readonly HashSet<IObjectWithChangeTracker> _allEntities;

        // Index de la clé finale qui sera utilisée dans le contexte (il peut être réel pour non ajouté, ou temporaire pour ajouté)
        // de la clé temporaire initiale
        private readonly Dictionary<EntityKey, EntityKey> _temporaryKeyMap;

        public EntityIndex(ObjectContext context)
        {
            _context = context;

            _allEntities = new HashSet<IObjectWithChangeTracker>();
            _temporaryKeyMap = new Dictionary<EntityKey, EntityKey>();
        }

        public void Add(ObjectStateEntry entry, ObjectChangeTracker changeTracker)
        {
            EntityKey temporaryKey = entry.EntityKey;
            EntityKey finalKey;

            if (!_allEntities.Contains(entry.Entity))
            {
                // Suivre le faire que cet Apply gérera cette entité
                _allEntities.Add(entry.Entity as IObjectWithChangeTracker);
            }

            if (changeTracker.State == ObjectState.Added)
            {
                finalKey = temporaryKey;
            }
            else
            {
                finalKey = _context.CreateEntityKey(temporaryKey.EntityContainerName + "." + temporaryKey.EntitySetName, entry.Entity);
            }
            if (!_temporaryKeyMap.ContainsKey(finalKey))
            {
                _temporaryKeyMap.Add(finalKey, temporaryKey);
            }
        }

        public bool Contains(object entity)
        {
            return _allEntities.Contains(entity);
        }

        public IEnumerable<IObjectWithChangeTracker> AllEntities
        {
            get { return _allEntities; }
        }

        // Convertit l'EntityKey passé à l'EntityKey utilisable par l'état actuel d'ApplyChanges
        public EntityKey ConvertEntityKey(EntityKey targetKey)
        {
            ObjectStateEntry targetEntry;
            if (!_context.ObjectStateManager.TryGetObjectStateEntry(targetKey, out targetEntry))
            {
                // S'il n'existe aucune entrée, alors soit :
                // 1. Il s'agit d'une EntityKey qui n'est pas représentée dans l'ensemble d'entités traité pendant l'Apply
                // 2. Il s'agit d'une EntityKey qui représentera l'une des entrées Added à traiter, vous devez donc la rechercher
                EntityKey temporaryKey;
                if (_temporaryKeyMap.TryGetValue(targetKey, out temporaryKey))
                {
                    targetKey = temporaryKey;
                }
            }
            return targetKey;
        }
    }

    // RelationshipSet génère une liste de toutes les relations à partir d'un
    // ensemble initial d'entités
    private sealed class RelationshipSet : IEnumerable<RelationshipWrapper>
    {
        private readonly HashSet<RelationshipWrapper> _relationships;
        private readonly ObjectContext _context;

        public RelationshipSet(ObjectContext context, IEnumerable<object> allEntities)
        {
            _context = context;
            _relationships = new HashSet<RelationshipWrapper>();
            foreach (object entity in allEntities)
            {
                ObjectStateEntry entry = context.ObjectStateManager.GetObjectStateEntry(entity);
                foreach (IRelatedEnd relatedEnd in entry.RelationshipManager.GetAllRelatedEnds())
                {
                    if (!((AssociationType)relatedEnd.RelationshipSet.ElementType).IsForeignKey)
                    {
                        foreach (object targetEntity in relatedEnd)
                        {
                            Add(relatedEnd, entity, targetEntity, EntityState.Unchanged);
                        }
                    }
                }
            }
        }

        // Ajoute une entrée à l'index selon un IRelatedEnd
        public void Add(IRelatedEnd relatedEnd, object sourceEntity, object targetEntity, EntityState state)
        {
            RelationshipWrapper wrapper = new RelationshipWrapper(
                                (AssociationSet)relatedEnd.RelationshipSet,
                                relatedEnd.SourceRoleName,
                                sourceEntity,
                                relatedEnd.TargetRoleName,
                                targetEntity,
                                state);
            if (!_relationships.Contains(wrapper))
            {
                _relationships.Add(wrapper);
            }
        }

        // Supprime une entrée de l'index en fonction d'une relation ObjectStateEntry
        public void Remove(ObjectStateEntry relationshipEntry)
        {
            Debug.Assert(relationshipEntry.IsRelationship);
            AssociationSet associationSet = (AssociationSet)relationshipEntry.EntitySet;
            DbDataRecord values = relationshipEntry.State == EntityState.Deleted ? relationshipEntry.OriginalValues : relationshipEntry.CurrentValues;
            int fromOridinal = values.GetOrdinal(associationSet.ElementType.AssociationEndMembers[0].Name);
            object fromEntity = _context.ObjectStateManager.GetObjectStateEntry((EntityKey)values.GetValue(fromOridinal)).Entity;
            int toOridinal = values.GetOrdinal(associationSet.ElementType.AssociationEndMembers[1].Name);
            object toEntity = _context.ObjectStateManager.GetObjectStateEntry((EntityKey)values.GetValue(toOridinal)).Entity;

            if (fromEntity != null && toEntity != null)
            {
                RelationshipWrapper wrapper = new RelationshipWrapper(
                    associationSet,
                    associationSet.ElementType.AssociationEndMembers[0].Name,
                    fromEntity,
                    associationSet.ElementType.AssociationEndMembers[1].Name,
                    toEntity,
                    EntityState.Unchanged);

                _relationships.Remove(wrapper);
            }
        }

        #region IEnumerable<RelationshipWrapper>

        public IEnumerator<RelationshipWrapper> GetEnumerator()
        {
            return _relationships.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _relationships.GetEnumerator();
        }

        #endregion
    }

    // Un RelationshipWrapper sert à identifier une relation entre deux entités
    // La relation est identifiée par l'AssociationSet, ainsi que par l'ordre des entités, en fonction
    // de leur rôle (via AssociationEndMember)
    private sealed class RelationshipWrapper : IEquatable<RelationshipWrapper>
    {
        internal readonly AssociationSet AssociationSet;
        internal readonly object End0;
        internal readonly object End1;
        internal readonly EntityState State;

        internal RelationshipWrapper(AssociationSet extent,
                                     string role0, object end0,
                                     string role1, object end1,
                                     EntityState state)
        {
            Debug.Assert(null != extent, "null AssociationSet");
            Debug.Assert(null != (object)end0, "null end0");
            Debug.Assert(null != (object)end1, "null end1");

            AssociationSet = extent;
            Debug.Assert(extent.ElementType.AssociationEndMembers.Count == 2, "2 fins seulement sont prises en charge");

            State = state;

            if (extent.ElementType.AssociationEndMembers[0].Name == role0)
            {
                Debug.Assert(extent.ElementType.AssociationEndMembers[1].Name == role1, "a)Le nom de roleAndKey1 diffère");
                End0 = end0;
                End1 = end1;
            }
            else
            {
                Debug.Assert(extent.ElementType.AssociationEndMembers[0].Name == role1, "b)Le nom de roleAndKey1 diffère");
                Debug.Assert(extent.ElementType.AssociationEndMembers[1].Name == role0, "b)Le nom de roleAndKey0 diffère");
                End0 = end1;
                End1 = end0;
            }
        }

        internal ReadOnlyMetadataCollection<AssociationEndMember> AssociationEndMembers
        {
            get { return this.AssociationSet.ElementType.AssociationEndMembers; }
        }

        public override int GetHashCode()
        {
            return this.AssociationSet.Name.GetHashCode() ^ (this.End0.GetHashCode() + this.End1.GetHashCode());
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as RelationshipWrapper);
        }

        public bool Equals(RelationshipWrapper wrapper)
        {
            return (Object.ReferenceEquals(this, wrapper) ||
                    ((null != wrapper) &&
                     Object.ReferenceEquals(this.AssociationSet, wrapper.AssociationSet) &&
                     Object.ReferenceEquals(this.End0, wrapper.End0) &&
                     Object.ReferenceEquals(this.End1, wrapper.End1)));
        }
    }
}
<#+
}
#>
